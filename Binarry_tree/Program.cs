int[,] tree = new int[4, 100]; //Таблица, которая будет содержать бинарное дерево
int[] start_number = { 44, 40, 29, 13, 48, 36, 43 }; //Начальные данные
for (int i = 0; i <= 99; i++) //Присваивание всем значением первого столбца в таблице значения "-1".                           
{
    tree[0, i] = -1;
}
tree[0, 0] = 1; //Ввод номера коренной ячейки
tree[1, 0] = start_number[0]; //Ввод значения коренной ячейки
int j; //Переменная для поиска свободной ячейки
for (int i = 0; i < start_number.Length; i++) //Цикл ввода ячеек
{
    j = 0; //Начиная с первой ячейки...
    Add(ref tree, start_number[i], j); //Вызов класса вставки ячейки
}
Console.WriteLine("№\t" + "key\t" + "left\t" + "right\t");
for (int i = 0; tree[0, i] != -1; i++) //Вывод таблицы
{
    Console.WriteLine(tree[0, i] + "\t" + tree[1, i] + "\t" + tree[2, i] + "\t" + tree[3, i] + "\t");
}

Console.WriteLine("Рекурсивный метод:");
See(0); //Рекурсивны симметрический обход
Console.WriteLine("\n\tИли");

Console.WriteLine("Итеративный метод:");
j = 0;
Stack<int> preparent = new Stack<int>(7); //Запоминание прошедших узлов для последующего возращения к ним
Stack<int> done = new Stack<int>(7); //Уже полностью проверенные узлы

while (true) //Цикл итеративного обхода
{
    if (tree[2, j] != 0 && done.Contains(tree[2, j] - 1) == false) //Если число слева не отсутствует
                                                                   //И его нет в стэкэ проверенных...
    {
        preparent.Push(j); //Помещаем узел в стэк "запоминания"
        j = tree[2, j] - 1; //Переходим в узел слева
    }
    else if (tree[3, j] != 0 && done.Contains(j) == false) //Иначе Если число справа не отсутствует и
                                                           //его нет в стэкэ проверенных...
    {
        Console.Write(tree[1, j] + ";"); //Выводим текущий узел
        done.Push(j); //Помещаем узел в стэк проверенных
        j = tree[3, j] - 1; //Переходим в узел справа
    }
    else if (preparent.Count != 0) //Иначе Если стэк "запоминания" не пуст...
    {
        Console.Write(tree[1, j] + ";"); //Выводим текущий узел
        done.Push(j); //Помещаем узел в стэк проверенных
        j = preparent.Pop(); //Переходим в последний сохраненный в стэк "запоминания" узел
    }
    else //Иначе... (Если элемент остался только один)
    {
        Console.Write(tree[1, j] + ";"); //Выводим текущий узел
        break; //Прекращаем работу цикла
    }
}

Console.WriteLine("\n Перед узлом с ключем 29 находиться узел с ключем " + Tree_predecessor(0, 29, 0));

static void Add(ref int[,] tree, int some, int j) //Класс вставки новой ячейки
{
    int i;
    if (some < tree[1, j]) //Если введенное значение меньше значения данной ячейки...
    {
        if (tree[2, j] == 0) //Если нет наследника
        {
            for (i = j + 1; i <= 99; i++) // До конца таблицы..
            {
                if (tree[0, i] == -1) //Если ячейка не занята...
                {
                    tree[0, i] = i + 1; //Ставим номер на пустой ячейке
                    tree[1, i] = some;  //Ставим значение в пустую ячейку
                    tree[2, j] = i + 1; //Устанавливаем наследование
                    break;
                }
            }
        }
        else // Если наследник есть
        {
            i = tree[2, j]; // Ставим номер наследника как основной
            Add(ref tree, some, i - 1); // Рекурсия
        }
    }
    else if (some > tree[1, j])
    {
        if (tree[3, j] == 0)
        {
            for (i = j + 1; i <= 99; i++)
            {
                if (tree[0, i] == -1)
                {
                    tree[0, i] = i + 1;
                    tree[1, i] = some;
                    tree[3, j] = i + 1;
                    break;
                }
            }
        }
        else
        {
            i = tree[3, j];
            Add(ref tree, some, i - 1);
        }

    }

}

void See(int x) //Функция обхода дерева
{
    if (tree[0, x] != -1) //Если узел существует...
    {
        if (tree[2, x] != 0)//Если узел слева существует
        {
            See(tree[2, x] - 1); //Берем левый узел как основной (Рекурсия)
        }
        Console.Write(tree[1, x] + ";"); //Вывод узла
        if (tree[3, x] != 0) //Если узел слева существует
        {
            See(tree[3, x] - 1); //Берем правый узел как основной (Рекурсия)
        }
    }

}

int Tree_predecessor(int x, int gde, int pre_uzel) //Нахождение предшевствующего узла
{
    while (true)
    {
        if ((tree[1, x] < gde) && (tree[3, x] != -1)) //Если данное число больше значения ключа текущего узла
        {
            pre_uzel = x; //Сохранение текущего узла как предыдущего
            x = tree[3, x] - 1; //Переход на узел вправо
        }
        else if ((tree[1, x] > gde) && (tree[3, x] != -1)) //Если данное число меньше значения ключа текущего узла
        {
            pre_uzel = x;
            x = tree[2, x] - 1; //Переход на узел влево
        }
        else if (tree[1, x] == gde) //Если данное число имеет значение ключа текущего узла
        {
            return tree[1, pre_uzel]; // Возвращаем значение ключа предшевствущего узла
            break;
        }
    }


}


